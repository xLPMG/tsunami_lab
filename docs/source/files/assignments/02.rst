2. Finite Volume Discretization
*********************************

All project authors contributed to this assignment in equal parts.

Task 2.0
===============

Task 2.0.1 - F-Wave solver integration
-----------------------------------------

To allow for an easy change of which solver will be used, we implemented another input parameter into the main class:

(**File: main.cpp**)

.. code:: cpp

    if(i_argc >= 3){
        if(std::string(i_argv[2]) == "roe" || std::string(i_argv[2]) == "fwave"){
            l_solver = i_argv[2];
        }else {
            std::cout << "invalid argument: solver parameter only accepts: roe, fwave" << std::endl;
            return EXIT_FAILURE;
        }
    }else{
        l_solver = "fwave";
    }

.. note:: 
    The ``WavePropagation1d`` class depends on a set solver. 
    Furthermore, the chosen solver will not change within one query. 
    Therefore we decided on just passing the solver as a parameter to the ``WavePropagation1d`` class constructor.
    This allows for an easy implementation without setters and getters:

.. code:: cpp

    tsunami_lab::patches::WavePropagation *l_waveProp;
    l_waveProp = new tsunami_lab::patches::WavePropagation1d( l_nx, l_solver );

In the ``WavePropagation1d.cpp`` file, we make use of simple if-conditions to utilize the correct solver:

(**File: WavePropagation1d.cpp**)

.. code::

    if(m_solver=="roe") { ... }
    else if(m_solver=="fwave") { ... }

Task 2.0.2 - Sanity check using middle_states.csv
----------------------------------------------------

Code documentation
^^^^^^^^^^^^^^^^^^^

Before we can start calculating and checking results, we need a way to read the data from the `csv` file.

To do so, we started by extending the ``Csv.cpp`` file by a ``splitLine()`` function:

(**File: Csv.cpp**)

.. code:: cpp

    std::vector<std::string> tsunami_lab::io::Csv::splitLine(std::stringstream line, 
                                                             char separator)
    {
        std::vector<std::string> result;
        std::string word;
        while (getline(line, word, separator))
            result.push_back(word);
        return result;
    }

This function takes one line as a stringstream of the `csv` file as one input 
and the character which separates the different values as another.
The output is a vector of strings, which represents the, by the separator character, separated values of the `csv` file.

.. note::
    Because the middle_states sanity check is much more extensive code- and time consumption-wise, we decided to implement it 
    in a new and separate executable: ``sanitychecks``. 

In ``sanitychecks.cpp`` there are currenty 3 functions: ``main()``, ``middleStatesSanityCheck()`` and ``calculateHStar()``. 
We will go through all of them here individually.

The main function will simply serve as an entry point for all upcoming sanity checks. 
If one of them fails, the whole executable will return ``EXIT_FAILURE``.

**File: sanitychecks.cpp**

.. code:: cpp

    int main()
    {
        if (middleStatesSanityCheck() != 0)
            return EXIT_FAILURE;
        return 0;
    }

The next function is ``middleStatesSanityCheck()``. To start off, we are given two options for adjustability:

.. code:: cpp

    // accuracy when comapring given hStar to calculated value
    tsunami_lab::t_real l_accuracy = 0.001;
    // amount of tests to run
    tsunami_lab::t_real l_tests = 10000;

.. note::
    The ``middle_states.csv`` file currently contains 1 million samples. 
    The ``l_tests`` variable determines how many of those will be used, starting from the top of the document.


Next, the ``middle_states.csv`` file is loaded up and ``splitLine()`` is called for each line which
does not start with a `#`. With the values returned by ``splitLine()`` we call the ``calculateHStar()`` function.
While its name is already pretty self explanatory, we will take a closer look at the calculation process later.
The ``middleStatesSanityCheck()`` function then compares the calculated hStar value to the given one:

.. code::

      // compare calculated and given values
      std::cout << "hStar diff: " << abs(l_hStar - std::stof(l_row[4])) << std::endl;
      if (abs(l_hStar - std::stof(l_row[4])) > l_accuracy)
      {
        std::cout << "TEST FAILED" << std::endl;
      }
      else
      {
        l_passedTests++;
      }
      l_executedTests++;

While it does so, it keeps track of how many tests were executed and how many of them actually passed.
This is useful, because:

.. note::
    We decided that it suffices to only require at least 99% of all tests to pass. 
    
A simple if-else-clause was used to implement the requirement.

.. code:: cpp

    if (l_passedTests >= 0.99 * l_executedTests)
    {
        std::cout << "MIDDLE STATES TEST PASSED" << std::endl;
        return 0;
    }
    else
    {
        std::cout << "MIDDLE STATES TEST FAILED" << std::endl;
        return EXIT_FAILURE;
    }

Now onto how we calculate hStar.

``calculateHStar()`` starts off with a few variables for adjustability:

.. code:: cpp

    // cell amount in x and y direction
    tsunami_lab::t_idx l_nx = 100;
    tsunami_lab::t_idx l_ny = 1;
    // simulation size
    tsunami_lab::t_real l_dxy = 10.0 / l_nx;
    // amount of calculated steps (more steps -> higher accuracy)
    tsunami_lab::t_idx l_steps = 1000;
    // solver choice
    std::string l_solver = "fwave";

While most of those parameters are already known from the ``main.cpp`` file,
we introduced ``l_steps`` to switch from a time limit to a step limit here. 
This value defines the amount of calculation steps each simulation will do.
For now we chose the value 1000 because it seems to be a sweet spot between the accuracy and 
calculation time we are looking for.

Next, we use a new setup ``MiddleStates``, set up the solver and run the simulation:

.. code::

    // iterate given amount of steps
    tsunami_lab::t_idx l_i;
    for (l_i = 0; l_i < l_steps; l_i++)
    {
        l_waveProp->setGhostOutflow();
        l_waveProp->timeStep(l_scaling);
    }
    // return height at the location of the discontinuity
    return l_waveProp->getHeight()[(int)(l_dxy / 2)];
    }

At the end, the function returns the water height at the location of the discontinuity, hStar.

To finish this task, we will take a brief look into the ``MiddleStates`` setup:

(You may view the inputs and outputs here: :ref:`ns-setups`)

(**File: MiddleStates.cpp**)

.. code::

    tsunami_lab::t_real tsunami_lab::setups::MiddleStates::getHeight(t_real i_x,
                                                                 t_real) const
    {
        return i_x < m_xdis ? m_heightLeft : m_heightRight;
    }

    tsunami_lab::t_real tsunami_lab::setups::MiddleStates::getMomentumX(t_real i_x,
                                                                    t_real) const
    {
        return i_x < m_xdis ? m_momentumLeft : m_momentumRight;
    }

This setup is a simple 1d discontinuity problem, where values for left and right
are returned on the basis of a given discontinuity location ``m_xdis``.

.. note:: 
    ``getMomentumY`` always returns 0.

Usage
^^^^^^^^^^

To execute the ``sanitychecks`` file, simply run

.. code:: bash

    ./build/sanitychecks

from inside the ``tsunami_lab`` folder.

.. note::
    Since the path of the ``middle_states.csv`` file is hard coded, it is imperative
    to execute the ``sanitychecks`` executable from the root directoy of the project.

Task 2.0.3 - Continuous Integration
-------------------------------------

The project code is automatically tested using GitHub actions on push and pull-requests, as well as
every night at 12am. This applies to the `main` and `dev` branch. 
View the ``.github/workflows/main.yml`` file for further information.

The project documentation is automatically built using GitHub actions on push and pull-requests, as well as
every night at 12am. This applies only to the `main` branch. 
The compiled data is pushed into the `gh-pages` branch and from there hosted using GitHub pages.
View the ``.github/workflows/docs.yml`` file for further information.

Task 2.1 Shock and Rarefaction Waves
=======================================

Since :math:`h_l = h_r`, both setups only require one shared height input `i_h` for both sides. 
And because of :math:`(hu)_r = -(hu)_l`, it suffices to either take :math:`(hu)_l` or :math:`(hu)_r` as the second input,
as we can derive the other momentum easily. For further information see :ref:`ns-setups`.

Since for both problems the `getMomentumY()` function returns 0 in all cases, we won't address it any further.

Task 2.1.1 - Implementation of Shock-Shock and Rare-Rare problems
-------------------------------------------------------------------
Initial conditions are the following: 

.. math:: 
    \begin{split}q_l=
        \begin{bmatrix}
          h_l \\ (hu)_l
    \end{bmatrix}, \quad
      q_r =
    \begin{bmatrix}
          h_r \\ (hu)_r
        \end{bmatrix} =
        \begin{bmatrix}
          h_l \\ -(hu)_l
    \end{bmatrix}.\end{split}


Shock-Shock Problem
^^^^^^^^^^^^^^^^^^^^
The following setup for the Shock Shock scenario determines the choice of :math:`hu` for either side.

.. math:: 
    \begin{split}\begin{cases}
        Q_i = q_{l} \quad &\text{if } x_i \le x_\text{dis} \\
        Q_i = q_{r} \quad &\text{if }   x_i > x_\text{dis}
    \end{cases} \qquad q_l \in \mathbb{R}^+ \times \mathbb{R}^+, \; q_r \in \mathbb{R}^+ \times \mathbb{R}^-,\end{split}

As already mentioned, the height is on both sides the same. In contrast to that, 
:math:`hu` varies depending on :math:`x_\text{dis}`. Therefore, :math:`(hu)_r` equals :math:`-(hu)_l`, if :math:`x_i` > :math:`x_\text{dis}`.
Otherwise :math:`(hu)_l` stays the same.


.. code:: cpp

    tsunami_lab::t_real tsunami_lab::setups::ShockShock1d::getHeight( t_real,
                                                                      t_real  ) const {
        return m_height;
    }

    tsunami_lab::t_real tsunami_lab::setups::ShockShock1d::getMomentumX( t_real i_x,
                                                                         t_real  ) const {
        return i_x <= m_xdis ? m_momentumLeft : -m_momentumLeft;
    }

Rare-Rare Problem
^^^^^^^^^^^^^^^^^^^^

Similarly to the problem before, the rare-rare problem has a setup for for accessing :math:`hu`.
Only this time :math:`(hu)_r` equals :math:`-(hu)_l`, when :math:`x_i \le x_\text{dis}`.

.. math:: 
    \begin{split}\begin{cases}
        Q_i = q_{r} \quad &\text{if } x_i \le x_\text{dis} \\
        Q_i = q_{l} \quad &\text{if }   x_i > x_\text{dis}
    \end{cases} \qquad q_l \in \mathbb{R}^+ \times \mathbb{R}^+, \; q_r \in \mathbb{R}^+ \times \mathbb{R}^-,\end{split}

.. code:: cpp

    tsunami_lab::t_real tsunami_lab::setups::RareRare1d::getHeight( t_real,
                                                                    t_real  ) const {
        return m_height;
    }

    tsunami_lab::t_real tsunami_lab::setups::RareRare1d::getMomentumX( t_real i_x,
                                                                       t_real  ) const {
        return i_x <= m_xdis ? -m_momentumLeft : m_momentumLeft;
    }

Task 2.1.2 - Observations
--------------------------

Task 2.2 - Dam-Break
======================

Task 2.2.1 
--------------------------

Visualizations
^^^^^^^^^^^^^^^^^

Roe solver with input 100 (cells in x direction) 

Input: :math:`h_l=40` and :math:`h_r=10`

.. raw:: html

    <video width="100%" height="auto" controls>
      <source src="../../_static/assets/DamBreak_hl40_hr10.mp4" type="video/mp4">
    </video> 
    <br />
|

Input: :math:`h_l=40` and :math:`h_r=30`

.. raw:: html

    <video width="100%" height="auto" controls>
      <source src="../../_static/assets/DamBreak_hl40_hr30.mp4" type="video/mp4">
    </video> 
    <br />
|

Input: :math:`h_l=20` and :math:`h_r=10`

.. raw:: html

    <video width="100%" height="auto" controls>
      <source src="../../_static/assets/DamBreak_hl20_hr10.mp4" type="video/mp4">
    </video> 
    <br />

|

Observations
^^^^^^^^^^^^^^^^^
As seen in the simulations, the momentum is getting higher, as :math:`h_l` and the difference between :math:`h_l` and :math:`h_r` grow. 
In the end, the water approaches a height between :math:`h_l` and :math:`h_r`